# üõ°Ô∏è Cliff-Watch: The Human Craftsmanship Firewall

> **"Incentivizing focus in the age of synthetic noise."**

![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)
![Build Status](https://img.shields.io/badge/build-passing-brightgreen)
![Version](https://img.shields.io/badge/version-5.2%20(Elite)-blue)
![Tests](https://img.shields.io/badge/tests-64%2F64-success)

**Cliff-Watch** is a decentralized governance protocol for Git repositories designed to protect code quality from low-fidelity AI spam. It validates human focus and cognitive effort through thermodynamic metrics, ensuring that every commit reflects genuine understanding rather than mindless copy-pasting.

---

## üìñ Table of Contents
- [The Mission](#-the-mission)
- [Core Technologies](#-core-technologies)
- [How It Works](#-how-it-works)
- [Installation](#-installation)
- [Usage Workflow](#-usage-workflow)
- [Configuration](#-configuration)
- [The Mathematical Model](#-the-mathematical-model)
- [License](#-license)

---

## üéØ The Mission

As Large Language Models lower the cost of code generation to near zero, open-source maintainers are being overwhelmed by **"synthetic noise"**‚Äîuntested, uncurated, and often buggy contributions.

**Cliff-Watch flips the incentive.** It introduces a "Proof of Work" based on **Human Attention**. It doesn't block AI; it blocks *laziness*. By enforcing a thermodynamic cost for every commit, we ensure that the author has spent the necessary cognitive energy (represented as "Battery") to justify the change.

---

## üß† Core Technologies (v5.2 Elite)

### 1. üìâ Real NCD (Normalized Compression Distance)
We killed the magic numbers. Cliff-Watch uses **Zstandard** to measure the actual entropy density of your edits.
- **Originality Detection**: The system samples your repository to ensure new code isn't just a clone of existing logic (`calculate_ncd_against_context`).
- **Spam Filtering**: Automatically flags high-compression boilerplate (NCD < 0.15) typically generated by uncurated AI outputs.

### 2. üìà Temporal Memory (EMA)
Human work isn't linear. Our **Exponential Moving Average (EMA)** engine (80/20 split) tracks your "Humanity Score" across time.
- Prevents volatility: One trivial commit won't destroy your reputation.
- Detects trends: Sustained low-quality work degrades the score over time.

### 3. üîã The Thermodynamic Battery
Every commit has an **Entropic Cost**.
- You "charge" your battery through focused time, keyboard interaction, and mouse kinematics.
- You "spend" battery by committing complex code.
- **Outcome**: You cannot commit a massive 500-line refactor in 2 seconds. The laws of thermodynamics forbid it.

### 4. ÔøΩÔ∏è Sovereign Privacy
- **Local-First**: All telemetry is processed locally on your machine.
- **Zero-Knowledge**: The system generates proofs of effort without exposing the actual content of your keystrokes.

---

## ‚öôÔ∏è How It Works

1.  **The Daemon (`cliff-watch-daemon`)**: Runs in the background (user-space). It monitors file events (`notify`), keyboard activity (generic input), and IDE focus states. It maintains the "Battery" state.
2.  **The Hook (`pre-commit`)**: When you run `git commit`, this hook queries the daemon.
    - "Do I have enough energy for this diff?"
    - "Is this code original or a paste?"
3.  **The CLI (`cliff-watch`)**: Manage the daemon, view metrics, and configure thresholds.

---

## üöÄ Installation

### Prerequisites
- Linux (Systemd support recommended for daemon persistence)
- Rust toolchain (`cargo`)

### Build from Source
```bash
# Clone the repository
git clone https://github.com/iodevs-net/cliff-watch.git
cd cliff-watch

# Build Release Binary
cargo build --release --features "ast-analysis"

# Install System-wide (Optional)
sudo cp target/release/cliff-watch /usr/local/bin/
```

### Quick Setup
Initialize Cliff-Watch in any Git repository:

```bash
cd /path/to/your/repo
cliff-watch init  # Installs hooks and config
cliff-watch on    # Starts the daemon
```

---

## üíª Usage Workflow

### 1. The "Flow"
Just code normally. The daemon quietly observes your focus sessions.
- **High Focus**: Coding, navigating files, small edits. -> **Battery Charges üîã**
- **Distraction**: Switching windows, idle time. -> **Battery Drains ü™´**

### 2. The Commit
```bash
git commit -m "feat: amazing new feature"
```
The hook runs automatically:
- **‚úÖ Success**: Ticket signed. Commit proceeds.
- **‚ö†Ô∏è Audit Warning**: (If `audit_mode = true`) Commit proceeds, but logs a warning about low focus/humanity.
- **‚ùå Blocked**: (If `audit_mode = false`) Commit rejected. "Thermodynamic Failure". Go back and review your code.

### 3. View Metrics
Check your current stats at any time:
```bash
cliff-watch metrics
```
Output:
```text
GovMonitor - Estado Termodin√°mico v2.1:
  üîã Energ√≠a (Kin√©tica+Foco): 85.0%
  üß† Acoplamiento Cognitivo:  0.92
  üõ°Ô∏è  Human Probability:     88.0%
```

---

## üîß Configuration (`cliff-watch.toml`)

Control the rigorousness of the protocol.

```toml
[governance]
# Difficulty: Easy, Normal, Hardcore
difficulty = "Normal"
# Minimum Entropy required (2.5 bits/byte default)
min_entropy = 2.5
# Audit Mode: If true, warns instead of blocking (Recommended for teams)
audit_mode = true

[monitoring]
debounce_window_ms = 500
ignore_extensions = ["log", "lock", "tmp"]
```

---

## üìê The Mathematical Model

Cliff-Watch relies on the **Cognitive-Kinematic Coupling** theory.

### 1. Human Score Calculation
$$ H = 0.4 \cdot B + 0.4 \cdot N + 0.2 \cdot F $$
Where:
- $B$ is **Burstiness** (Pareto distribution of edit intervals).
- $N$ is **NCD** (Normalized Compression Distance vs. Repo Context).
- $F$ is **Focus Continuity**.

### 2. Entropic Cost
The cost $E$ to commit a change is derived from its Information Density:
$$ E(diff) = \text{size}(diff) \times \frac{\text{zstd}(diff)}{\text{size}(diff)} \times \text{SemanticWeight} $$

This ensures that 1000 lines of "Lorem Ipsum" cost almost nothing (low entropy), while 50 lines of dense, novel Rust logic cost significantly more battery.

---

## ü§ù Contributing

We welcome contributions that improve the accuracy of our metrics or add support for new IDEs/Editors.

1.  Fork the Project
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  Commit your Changes (Yes, you'll need to pass the checks!)
4.  Push to the Branch
5.  Open a Pull Request

## üìÑ License

Distributed under the MIT License. See `LICENSE` for more information.

---
*Built with ü¶Ä Rust for the Sovereign Developer. üõ°Ô∏è‚ú®*