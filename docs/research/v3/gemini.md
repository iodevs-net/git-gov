git-gov v2.1: Sovereign Code Governance via Proof of Human Work (PoHW)1. The Entropy Crisis: Redefining Value in the Post-Generative EraThe fundamental economic equation of open-source software—that code represents a scarce resource of human cognitive effort—has collapsed. For decades, the friction inherent in writing code served as a natural governance mechanism. The cognitive load required to understand a problem, architect a solution, and syntactically implement it acted as a "Proof of Work" (PoW) that filtered out low-commitment actors and ensured a baseline of intentionality. A pull request (PR) containing complex logic was, by definition, a signal of significant investment.The advent of Large Language Models (LLMs) and "agentic" coding frameworks has dismantled this heuristic. The marginal cost of generating syntactically correct, semantically plausible, yet functionally potentially incoherent or malicious code has approached zero. We are witnessing an "Entropy Crisis" where the digital commons face saturation by "Bio-Puppetry"—automated agents mimicking human commit patterns to bypass traditional identity verification. This report outlines the technical and theoretical architecture of git-gov v2.1, a sovereign governance protocol designed to reintroduce "friction" as a verification layer through a cryptographic Proof of Human Work (PoHW).1.1 The Threat Landscape: Bio-Puppetry and Synthetic SaturationThe adversary in this new landscape is not the traditional spam bot, which is easily detectable via heuristic filters or CAPTCHAs. The threat is the "Bio-Puppet": a sophisticated AI agent capable of emulating the artifacts of human work without the substance of human intent.Traditional governance relies on identity (Who are you?). This is vulnerable to Sybil attacks where an attacker generates thousands of "verified" accounts, each driven by an agent with a distinct coding persona. These agents can flood repositories with high-volume, low-entropy contributions that degrade maintainer attention and introduce subtle vulnerabilities.The git-gov project proposes shifting the verification axis from Identity (Who) to Behavior (How). By measuring the physical and cognitive constraints that bind human coding—constraints that LLMs currently simulate only imperfectly—we can distinguish between "Sovereign Code" (human-originated) and synthetic output.1.2 The "Proof of Human Work" ThesisThe core thesis of git-gov v2.1 is that human cognition leaves a distinct, unforgeable signature in the time-domain of code production. This signature is defined by three primary vectors:Burstiness: Human activity is characterized by periods of high-intensity output followed by pauses for cognitive processing (thinking), resulting in a heavy-tailed distribution of inter-event times.Entropic Complexity: Human code exhibits local entropy spikes (novelty) and high compression complexity, whereas LLM output minimizes perplexity (predictability).Correction and Jitter: Humans make errors and correct them non-linearly. The "backspace ratio" and the micro-jitter of keystrokes follow specific neuromuscular laws (Fitts's Law) that are computationally expensive to simulate perfectly in real-time.By capturing these signals and binding them to a cryptographic proof, we establish a "Customs House" for code—a gateway that verifies the provenance of effort before code enters the repository.2. The Physics of Cognition: Biometric Metrics and Theoretical ModelsTo quantify "Human Work" without relying on invasive surveillance or centralized identity providers, we must model the physics of the coding session itself. This chapter details the mathematical frameworks used to calculate the "Humanity Score" ($H_{score}$).2.1 Burstiness: The Temporal Signature of ThoughtThe most robust differentiator between human and machine generation is the temporal distribution of events. Machines, constrained by clock cycles and network latency, tend to stream data at a constant rate or with uniform random delays. Humans, constrained by cognitive load, operate in bursts.2.1.1 The Burstiness Parameter ($B$)We utilize the Burstiness parameter $B$ defined by Barabási and colleagues to quantify this behavior. The parameter is derived from the distribution of inter-event times ($\tau$).The standard formula for Burstiness is:$$B = \frac{\sigma_{\tau} - \mu_{\tau}}{\sigma_{\tau} + \mu_{\tau}}$$Where:$\sigma_{\tau}$ is the standard deviation of the inter-event times.$\mu_{\tau}$ is the mean of the inter-event times.This dimensionless parameter ranges from -1 to 1:$B = 1$: Indicates extremely bursty behavior. This correlates with human activities driven by priority-queue dynamics, where tasks (like typing a function) are executed rapidly, followed by long waiting times (thinking or debugging).$B = 0$: Indicates Poissonian (random) behavior. Events occur independently at a constant average rate.$B = -1$: Indicates periodic or regular behavior. This is the signature of a simple script or a "paste" event where characters are inserted at fixed intervals.Table 1: Comparative Burstiness ValuesSource TypeBurstiness (B)Memory (M)DescriptionHuman Typing$0.2 < B < 0.6$$> 0.1$High variance; distinct "trains" of activity.LLM Streaming$B \approx 0$$M \approx 0$Poissonian; token generation is stochastic but uniform.Scripted Injection$B \approx -1$$M \approx 1$Perfectly periodic; highly predictable.Paste EventN/AN/ASingle event; technically $B$ is undefined or -1.2.1.2 Finite Size Correction ($B_n$)Code commits are finite windows of activity. A single commit might represent only 5 minutes of work. The standard estimator for $B$ is biased for small sample sizes ($n$). To ensure fairness for small but legitimate commits (e.g., a "hotfix"), we implement the Kim and Jo correction for finite $n$ :$$B_n = \frac{\sqrt{n+1} r - \sqrt{n-1}}{(\sqrt{n+1} - 2)r + \sqrt{n-1}}$$Where $r = \sigma_{\tau} / \mu_{\tau}$ (the coefficient of variation). This corrected metric $B_n$ is what git-gov calculates internally. By enforcing a threshold based on $B_n$, we ensure that the "Proof of Work" requires a statistically significant duration of non-linear interaction.2.2 Lempel-Ziv Complexity as an Entropy ProxyWhile Burstiness measures the "rhythm" of work, Entropy measures its "information density." LLMs are trained to predict the next token based on probability maximization. Consequently, LLM-generated code tends to be "low perplexity" or highly predictable. Human code, particularly when solving novel problems, often exhibits higher local entropy ("surprise").To measure this efficiently on low-power hardware, we utilize Lempel-Ziv (LZ) complexity rather than calculating Shannon entropy directly, which would require building a complex probability model of the programming language.We define the Compression Complexity Ratio (CCR):$$CCR = \frac{L(C(S))}{L(S)}$$Where:$S$ is the input stream of keystrokes and navigation events.$C(S)$ is the compressed version of that stream using the LZ4 algorithm.$L$ denotes the length in bytes.Why LZ4?
We select LZ4  over algorithms like Deflate or Zstd for the sensor layer because of its extreme speed and minimal CPU footprint. The goal is not maximum compression but the ratio as a signal.Low CCR (< 0.2): Indicates high redundancy. This is typical of automated generation or copy-pasting repetitive boilerplate.High CCR (> 0.5): Indicates high complexity. This characterizes human editing, which involves non-linear navigation, variable renaming, and structural refactoring—patterns that compressors find harder to reduce.2.3 Cognitive Load and the Backspace RatioThe most distinct feature of human work is error. LLMs generate code linearly; they rarely "backspace" to correct a logic error during generation. Humans, conversely, engage in a continuous feedback loop of typing, reading, and correcting.Research in digital phenotyping links the "Backspace Ratio" to cognitive load. We define the Correction Ratio ($R_c$):$$R_c = \frac{N_{backspace} + N_{delete} + N_{undo}}{N_{total\_keystrokes}}$$A coding session with $R_c \approx 0$ is highly suspicious. It implies a "God-mode" typist who never makes a mistake. A session with $R_c > 0.05$ (5%) is a strong indicator of human interaction. The git-gov protocol requires a non-zero $R_c$ to validate a session, effectively blocking "perfect" AI generation unless the AI is specifically trained to simulate "human error" (which increases the computational cost for the attacker).3. Cryptographic Architecture: Zero-Knowledge ProofsThe challenge of git-gov is to verify these biometric metrics—Burstiness, Entropy, Correction—without creating a surveillance state. A developer should not be forced to upload their raw keystroke logs to a public server to prove they did the work.We solve this using Zero-Knowledge Proofs (ZKPs). Specifically, we employ Bulletproofs  to prove that the "Humanity Score" meets a governance threshold without revealing the score itself or the underlying data.3.1 Selection of ZK Framework: Why Bulletproofs?The ZK landscape is crowded with SNARKs, STARKs, and PLONK. For the specific constraints of git-gov—ultra-lightweight, no trusted setup, and integration into Git metadata—Bulletproofs are the optimal choice.Table 2: ZK Framework Comparison for git-govFeaturezk-SNARKs (Groth16)zk-STARKsBulletproofsTrusted SetupRequired (Risk)TransparentTransparentProof SizeSmall (~200B)Large (~45KB)Medium (~600B)VerificationFast ($O(1)$)Fast ($O(\log n)$)Linear ($O(n)$)HardwareHigh RAMHigh RAMLow RAMSuitabilityBlockchainRollupsCode SigningNo Trusted Setup: Unlike SNARKs, Bulletproofs do not require a "toxic waste" ceremony. This is critical for sovereign governance; we cannot rely on a central authority to generate parameters.Proof Size: A Bulletproof range proof is logarithmic in size ($O(\log n)$). A proof for a 64-bit range is approximately 600 bytes. This is small enough to be included in a Git commit trailer without bloating the repository history. STARKs, at 45KB+, would be prohibitive.Rust Ecology: The bulletproofs crate (developed by Dalek Cryptography) is a mature, pure-Rust implementation that integrates seamlessly with curve25519-dalek.3.2 The Range Proof CircuitThe core cryptographic task is to prove that the calculated Humanity Score ($S_H$) is greater than the repository's required threshold ($T$).We model $S_H$ as a secret value committed to using a Pedersen Commitment:$$V = S_H \cdot G + r \cdot H$$Where:$G$ and $H$ are generators of the Ristretto group (Curve25519).$r$ is a random blinding factor generated by the local daemon.$V$ is the public commitment.The circuit proves the statement:$$S_H - T \in [0, 2^{64}]$$This effectively proves $S_H \ge T$. If $S_H < T$, the subtraction would underflow in the scalar field, resulting in a large number outside the $[0, 2^{64}]$ range, causing the range proof to fail. This "Range Gadget" is efficient and requires no complex arithmetic circuit compilation (like R1CS).3.3 Hardware Binding: The Missing LinkA ZK proof proves that some value satisfies the condition. It does not prove who generated it or where it came from. A malicious actor could theoretically replay a valid proof from another session.To solve this, we bind the ZK proof to the physical hardware using the Trusted Platform Module (TPM) or Secure Enclave.The final signature attached to the commit is:$$\sigma = \text{Sign}_{HW}(\text{Hash}(\text{Commit} || V |
| \pi))$$
Where $\text{Sign}_{HW}$ is a signature generated by a non-exportable key inside the TPM/Enclave. This proves that the machine attesting to the work is the same machine signing the commit.4. System Architecture: The "Daemon-First" Security ModelA critical vulnerability in many "AI-defense" tools is their reliance on the environment they are trying to protect. A VS Code extension running in the editor process is vulnerable to manipulation by other extensions or the editor itself. git-gov v2.1 adopts a "Daemon-First" architecture to establish a trusted witness outside the editor's failure domain.4.1 The "Witness" Daemon (git-gov-core)The core of the system is a high-performance Rust daemon that runs in the background. It serves as the "Witness" to the coding session.Responsibility: It aggregates raw events, calculates the metrics ($B$, $CCR$, $R_c$), maintains the "Attention Battery," and generates the ZK proofs.Isolation: It runs as a separate process, isolated from the VS Code renderer. It is the only component with access to the hardware signing keys (TPM/Enclave).Efficiency: Built on the tokio async runtime, it uses Unix Domain Sockets (UDS) for low-latency communication (< 1ms) with the editor. The memory footprint is kept under 50MB using zero-copy serialization (bincode or rkyv).4.2 Secure IPC and Peer VerificationThe daemon must ensure that the events it receives are coming from a legitimate VS Code instance and not a headless script spoofing input.Verification Mechanism:When a client connects to the UDS, the daemon utilizes OS-level introspection to verify the peer's identity.Linux: The SO_PEERCRED socket option returns the ucred structure, containing the PID, UID, and GID of the connecting process.Rust// Rust Pseudo-code for Credential Check
let peer_cred = socket.peer_cred().expect("No credentials");
let pid = peer_cred.pid().expect("No PID");
let exe_path = fs::read_link(format!("/proc/{}/exe", pid))?;
if!is_authorized_binary(&exe_path) {
    return Err("Unauthorized client");
}
macOS: The LOCAL_PEERPID option is used similarly.This "Air Gap" ensures that even if a malicious script tries to inject events, the daemon will reject the connection unless the script successfully masquerades its process image as the signed VS Code binary—a significantly higher bar for the attacker.4.3 The "Attention Battery" (Leaky Bucket)To prevent "gaming" (e.g., typing randomly to build up a score and then pasting AI code), the daemon implements a Reverse Leaky Bucket algorithm.Accumulation: The "battery" charges only when the incoming event stream exhibits human characteristics ($B > 0.2$, $CCR > 0.4$).Leakage: The battery drains linearly over time.Threshold: A commit can only be signed if the battery charge $> T_{sign}$.Penalty: Large, instantaneous insertions (pastes) incur a "entropy penalty," instantly draining a portion of the battery. This forces the user to spend time reviewing (navigating, editing) the pasted code to recharge the battery before they can commit.This mechanism enforces a temporal cost on code production, reintroducing the "Proof of Work" dynamic.5. The Sensor Layer: VS Code IntegrationThe "Sensor" is a lightweight VS Code extension designed to be as "dumb" as possible to minimize the attack surface.5.1 Architecture: Extension-First UXWhile the security is "Daemon-First," the user experience is "Extension-First." The developer installs the git-gov extension, which automatically spawns the background daemon if it is not running (using child_process.spawn).Responsibilities:Event Capture: It subscribes to vscode.workspace.onDidChangeTextDocument and vscode.window.onDidChangeTextEditorSelection API events.Serialization: It bundles these events into a binary format (Timestamp, Delta, CursorPosition) and pushes them to the daemon's socket.Feedback: It renders a status bar item showing the current "Attention Battery" level, giving the developer real-time feedback on their "Humanity Score."5.2 Anti-Agentic DefensesThe extension must defend against "Bio-Puppetry" tools that might try to drive VS Code via accessibility APIs.Trusted UI: The extension uses the vscode.authentication API to bind the session to the developer's GitHub identity, ensuring that the "Human Work" is credited to the correct user.Jitter Analysis: The extension reports raw timeSinceLastKey with microsecond precision (using process.hrtime in Node.js). This allows the daemon to detect the "quantized" timing signatures of automated scripts that often run on the JavaScript event loop tick (approx 1ms resolution), whereas human typing has analog variance.6. Hardware Roots of Trust: The "Vault"The integrity of git-gov ultimately rests on hardware. If the private key used to sign the ZK proof can be stolen, the system fails. We utilize modern hardware security modules to make keys non-exportable.6.1 Linux: TPM 2.0 IntegrationOn Linux (and Windows), we rely on the Trusted Platform Module (TPM) 2.0.Key Generation: The daemon generates an RSA or ECC key pair within the TPM's "Endorsement Hierarchy." This key cannot leave the TPM.Attestation: We use the tpm2_quote command. The daemon sends the hash of the ZK proof to the TPM. The TPM signs this hash along with the current value of the Platform Configuration Registers (PCRs).PCR Binding: By including PCR values (which measure the boot state and kernel integrity), we ensure that the PoHW proof was generated on a machine running a trusted, uncompromised OS kernel.Rust Implementation:
We use the tpm2-tss-rs crate to interface directly with /dev/tpm0 or the tpm2-abrmd resource manager.6.2 macOS: Secure Enclave & App AttestOn macOS, we utilize the Apple Secure Enclave (SEP).Key Storage: Keys are generated using the CryptoKit or Security framework, flagged as .privateKeyUsage and stored in the Secure Enclave.Touch ID: We can configure the key to require User Presence (Touch ID) for every signing operation. This adds a biometric "second factor" to the commit process—you literally "fingerprint" your code.App Attest: Using the DeviceCheck / DCAppAttestService API, we can prove to the repository verifyier that the git-gov binary generating the proof is a legitimate, Apple-notarized binary and hasn't been tampered with.7. Governance & Standardization: The "Customs House" ProtocolThe final piece is integration with the Git ecosystem. We utilize standard Git features to ensure compatibility with existing tooling (GitHub, GitLab).7.1 Git Trailers: The Metadata EnvelopeWe store the Proof of Human Work in Git Trailers. Trailers are key-value pairs at the end of a commit message (like Signed-off-by). This is preferable to Git Notes or detached signatures as it ensures the proof travels atomically with the commit hash.Specification:Commit: 8f9d123...Author: Jane Doe jane@gov.codeDate:   Sat Jan 25 14:00:00 2026Implement sovereign consensus logic

Refactors the pBFT loop to handle latency spikes.

X-Gov-PoHW-Version: 2.1
X-Gov-PoHW-Metric-Burstiness: 0.42
X-Gov-PoHW-Metric-Entropy: 0.68
X-Gov-PoHW-Commitment: <Base64 Pedersen Commitment>
X-Gov-PoHW-Proof: <Base64 Bulletproof Range Proof>
X-Gov-PoHW-Signature: <Base64 TPM/Enclave Signature>
7.2 C2PA: Provenance for CodeWe align git-gov with the C2PA (Coalition for Content Provenance and Authenticity) standard. While C2PA is primarily used for media, its "Assertion" model is generic enough for code.Implementation:The Daemon acts as a C2PA Claim Generator. It creates a detached C2PA manifest (a .c2pa sidecar file or a blob in a hidden .provenance directory).Assertion 1: c2pa.actions = "Edited".Assertion 2: org.git-gov.pohw (Custom Assertion).Data: The ZK Proof and Commit Hash.Schema: Defined in JSONLD to allow interoperability.This enables future integration with "Content Credentials" browser extensions , allowing a user to see a "Verified Human" badge on GitHub UI elements.7.3 Sigstore & Rekor: Transparency LogTo prevent history rewriting (where a maintainer strips the proofs), we submit the commit hash and the PoHW proof to a Sigstore (Rekor) transparency log. This creates an immutable public record.Verification: A verifier can query Rekor to see if a commit has a valid PoHW associated with it, even if the git history was altered.8. Attack Analysis and MitigationNo security system is perfect. We must analyze the "break-even" cost for an attacker to bypass git-gov.8.1 Attack: The "Jitter Bot"Vector: An attacker trains a specialized AI model to generate keystrokes with human-like latency distributions (Log-Normal flight times) and injects them into the UDS.
Defense:Process Verification: The daemon checks that the injector is the signed VS Code binary (Section 4.2).Contextual Entropy: The "Jitter Bot" might fake the timing, but can it fake the contextual entropy? A human pauses at specific syntactic boundaries (e.g., after typing fn, before naming it). A bot using a generic delay distribution will pause randomly. The daemon analyzes Syntactic Burstiness—the correlation between pauses and Abstract Syntax Tree (AST) nodes.8.2 Attack: The ReplayVector: An attacker captures a valid ZK proof from User A and attaches it to their own commit.Defense: The Bulletproof transcript (Fiat-Shamir) absorbs the Git Commit Hash as part of the challenge generation.$$c = H(\text{CommitHash} || V || \dots)$$If the commit hash changes (different code), the proof $\pi$ becomes invalid for that commit. The proof is mathematically bound to the specific content of the work.8.3 Attack: The "Hybrid" BypassVector: A human types comments and variable names to charge the battery, then pastes the AI logic.Defense: The "Paste Penalty" in the Leaky Bucket algorithm. Large insertions drain the battery instantly. To commit, the user must regenerate the battery charge by interacting with the code (navigating, formatting, renaming), effectively forcing a "Human Review" period.9. Conclusion and RoadmapThe "Crisis of Entropy" is an existential threat to the open model of software development. If code becomes cheap, infinite, and unverifiable, the trust networks that bind the open-source community will dissolve.git-gov v2.1 offers a path forward. By treating the act of coding as a physical process with measurable biometric properties, we can construct a "Proof of Human Work" that is:Sovereign: Relying on local hardware (TPM) and math (ZKP), not central platforms.Private: Keeping behavioral data on the device.Resilient: Raising the cost of forgery from "zero" (API call) to "prohibitive" (physical emulation).9.1 Future HorizonsPost-Quantum ZKP: Moving from Bulletproofs (Discrete Log) to STARKs (Hash-based) to ensure long-term resistance against quantum adversaries.FIDO2++ Dongles: Offloading the "Witness" daemon to a dedicated USB hardware dongle that sits between the keyboard and the computer, providing an absolute physical root of trust that cannot be compromised by OS-level malware.This report establishes the technical foundation for the "Deep Research Omega" agent. The tools—Rust, Bulletproofs, TPMs—are ready. The integration is the innovation. It is time to build the Customs House.